// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Language plugin tests Explicit __typename selection throws when selecting a union without an explicit __typename selection 1`] = `
[GraphQLError: Unions and interfaces must have the field __typename explicitly selected. Please add __typename to the fields selected by "participantById" in your operation.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             participantById(id: "123") {
               ^
3:               ... on User {
]
`;

exports[`Language plugin tests Field names Cannot start with uppercase letter throws when trying to use a field name starting with an uppercase 1`] = `
[GraphQLError: Found an invalid field name: Field names may not start with an uppercase letter. Please alias the 'Observer' field to something starting with a lowercase letter.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             Observer(id: "123") {
               ^
3:               id
]
`;

exports[`Language plugin tests Field names Reserved keywords renames reserved keywords as field names in types when encountered 1`] = `
"// SomeMutation.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type mutationWithReservedNameInput = {
    [@bs.as \\"or\\"]
    or_: bool,
    [@bs.as \\"and\\"]
    and_: string,
    nested: option(mutationWithReservedNameInput),
  };

  type response = {mutationWithReservedName: bool};
  type rawResponse = response;
  type variables = {input: mutationWithReservedNameInput};
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"MutationWithReservedNameInput\\":{\\"nested\\":{\\"n\\":\\"\\",\\"r\\":\\"MutationWithReservedNameInput\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"MutationWithReservedNameInput\\"}}} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

module Utils = {
  open Types;
  let make_mutationWithReservedNameInput =
      (~or_, ~and_, ~nested=?, ()): mutationWithReservedNameInput => {
    or_,
    and_,
    nested,
  };

  let makeVariables = (~input): variables => {input: input};

  let makeOptimisticResponse = (~mutationWithReservedName): rawResponse => {
    mutationWithReservedName: mutationWithReservedName,
  };
};

type relayOperationNode;

type operationType = ReasonRelay.mutationNode(relayOperationNode);

"
`;

exports[`Language plugin tests Field names Reserved keywords throws when trying to use a field name that's a reserved keyword 1`] = `
[GraphQLError: Found an invalid field name: 'new' is a reserved keyword in ReasonML and therefore cannot be used as a field name. Please alias your field to something else.

Source: GraphQL request (3:17)
2:               user(id: "123") {
3:                 new
                   ^
4:               }
]
`;

exports[`Language plugin tests Fragment prints indications of existing fragment refs in generated types 1`] = `
"// SomeComponent_user.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];

  type fragment = {id: string};
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`SomeComponent_user]) => fragmentRef =
  \\"%identity\\";

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);



// SomeOtherComponent_user.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];

  type fragment = {
    fragmentRefs: ReasonRelay.fragmentRefs([ | \`SomeComponent_user]),
  };
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"\\":{\\"f\\":\\"\\"}}} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`SomeOtherComponent_user]) => fragmentRef =
  \\"%identity\\";

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Fragment prints the correct fragment ref extractor helpers and base types 1`] = `
"// SomeComponent_user.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];

  type fragment = {id: string};
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`SomeComponent_user]) => fragmentRef =
  \\"%identity\\";

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Mutation generates the correct converter for complex variables 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */

module Types = {
  type enum_UserRole = pri [> | \`Admin | \`User];

  [@ocaml.warning \\"-30\\"];
  type response_setUserLocation = {
    changedUser: option(response_setUserLocation_changedUser),
  }
  and response_setUserLocation_changedUser = {
    id: string,
    firstName: string,
    role: enum_UserRole,
  }
  and setUserLocationInput = {
    clientMutationId: option(string),
    userId: string,
    location: option(locationBounds),
  }
  and locationBounds = {
    lat: float,
    lng: float,
    child: option(locationBounds),
  };

  type response = {setUserLocation: response_setUserLocation};
  type rawResponse = response;
  type variables = {input: setUserLocationInput};
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"SetUserLocationInput\\":{\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"},\\"clientMutationId\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

module Utils = {
  external userRole_toString: Types.enum_UserRole => string = \\"%identity\\";
  open Types;
  let make_locationBounds = (~lat, ~lng, ~child=?, ()): locationBounds => {
    lat,
    lng,
    child,
  };

  let make_setUserLocationInput =
      (~clientMutationId=?, ~userId, ~location=?, ()): setUserLocationInput => {
    clientMutationId,
    userId,
    location,
  };

  let makeVariables = (~input): variables => {input: input};

  let make_response_setUserLocation_changedUser =
      (~id, ~firstName, ~role): response_setUserLocation_changedUser => {
    id,
    firstName,
    role,
  };

  let make_response_setUserLocation =
      (~changedUser=?, ()): response_setUserLocation => {
    changedUser: changedUser,
  };

  let makeOptimisticResponse = (~setUserLocation): rawResponse => {
    setUserLocation: setUserLocation,
  };
};

type relayOperationNode;

type operationType = ReasonRelay.mutationNode(relayOperationNode);

"
`;

exports[`Language plugin tests Mutation generates the correct type structure when fragments are included 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_setUserLocation = {
    changedUser: option(response_setUserLocation_changedUser),
  }
  and response_setUserLocation_changedUser = ReasonRelay.allFieldsMasked
  and setUserLocationInput = {
    clientMutationId: option(string),
    userId: string,
    location: option(locationBounds),
  }
  and locationBounds = {
    lat: float,
    lng: float,
    child: option(locationBounds),
  };

  type response = {setUserLocation: response_setUserLocation};
  type rawResponse = response;
  type variables = {input: setUserLocationInput};
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"f\\":\\"\\",\\"n\\":\\"\\"}}} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"f\\":\\"\\",\\"n\\":\\"\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"SetUserLocationInput\\":{\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"},\\"clientMutationId\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

module Utils = {
  open Types;
  let make_locationBounds = (~lat, ~lng, ~child=?, ()): locationBounds => {
    lat,
    lng,
    child,
  };

  let make_setUserLocationInput =
      (~clientMutationId=?, ~userId, ~location=?, ()): setUserLocationInput => {
    clientMutationId,
    userId,
    location,
  };

  let makeVariables = (~input): variables => {input: input};

  let make_response_setUserLocation_changedUser = () =>
    [@ocaml.warning \\"-27\\"] {};

  let make_response_setUserLocation =
      (~changedUser=?, ()): response_setUserLocation => {
    changedUser: changedUser,
  };

  let makeOptimisticResponse = (~setUserLocation): rawResponse => {
    setUserLocation: setUserLocation,
  };
};

type relayOperationNode;

type operationType = ReasonRelay.mutationNode(relayOperationNode);



// SomeFragment_user.graphql
/* @generated */

module Types = {
  type enum_UserRole = pri [> | \`Admin | \`User];

  [@ocaml.warning \\"-30\\"];

  type fragment = {
    firstName: string,
    role: enum_UserRole,
  };
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`SomeFragment_user]) => fragmentRef =
  \\"%identity\\";

module Utils = {
  external userRole_toString: Types.enum_UserRole => string = \\"%identity\\";
};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Mutation prints the correct basic structure for mutations 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_setUserLocation = {
    changedUser: option(response_setUserLocation_changedUser),
  }
  and response_setUserLocation_changedUser = {
    id: string,
    firstName: string,
  }
  and setUserLocationInput = {
    clientMutationId: option(string),
    userId: string,
    location: option(locationBounds),
  }
  and locationBounds = {
    lat: float,
    lng: float,
    child: option(locationBounds),
  };

  type response = {setUserLocation: response_setUserLocation};
  type rawResponse = response;
  type variables = {input: setUserLocationInput};
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"SetUserLocationInput\\":{\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"},\\"clientMutationId\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

module Utils = {
  open Types;
  let make_locationBounds = (~lat, ~lng, ~child=?, ()): locationBounds => {
    lat,
    lng,
    child,
  };

  let make_setUserLocationInput =
      (~clientMutationId=?, ~userId, ~location=?, ()): setUserLocationInput => {
    clientMutationId,
    userId,
    location,
  };

  let makeVariables = (~input): variables => {input: input};

  let make_response_setUserLocation_changedUser =
      (~id, ~firstName): response_setUserLocation_changedUser => {
    id,
    firstName,
  };

  let make_response_setUserLocation =
      (~changedUser=?, ()): response_setUserLocation => {
    changedUser: changedUser,
  };

  let makeOptimisticResponse = (~setUserLocation): rawResponse => {
    setUserLocation: setUserLocation,
  };
};

type relayOperationNode;

type operationType = ReasonRelay.mutationNode(relayOperationNode);

"
`;

exports[`Language plugin tests Node interface collapses single selections on the node interface 1`] = `
"// SomeQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_node = {
    __typename: [ | \`User],
    firstName: string,
  };

  type response = {node: option(response_node)};
  type rawResponse = response;
  type variables = unit;
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests Query connections generates helpers for connections with unions 1`] = `
"// TestPagination_query.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type fragment_participantsConnection_edges_node_User = {
    firstName: string,
    id: string,
  };
  type fragment_participantsConnection_edges_node_Observer = {
    name: string,
    id: string,
  };
  type fragment_participantsConnection_edges_node = [
    | \`User(fragment_participantsConnection_edges_node_User)
    | \`Observer(fragment_participantsConnection_edges_node_Observer)
    | \`UnselectedUnionMember(string)
  ];
  type fragment_participantsConnection = {
    edges: option(array(option(fragment_participantsConnection_edges))),
  }
  and fragment_participantsConnection_edges = {
    node:
      option(
        [
          | \`User(fragment_participantsConnection_edges_node_User)
          | \`Observer(fragment_participantsConnection_edges_node_Observer)
          | \`UnselectedUnionMember(string)
        ],
      ),
  };

  type fragment = {
    participantsConnection: option(fragment_participantsConnection),
  };
};

let unwrap_fragment_participantsConnection_edges_node:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.fragment_participantsConnection_edges_node_User)
    | \`Observer(Types.fragment_participantsConnection_edges_node_Observer)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | \\"Observer\\" => \`Observer(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_fragment_participantsConnection_edges_node:
  [
    | \`User(Types.fragment_participantsConnection_edges_node_User)
    | \`Observer(Types.fragment_participantsConnection_edges_node_Observer)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`Observer(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantsConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"participantsConnection_edges_node\\":{\\"n\\":\\"\\",\\"u\\":\\"fragment_participantsConnection_edges_node\\"},\\"participantsConnection\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let fragmentConverterMap = {
    \\"fragment_participantsConnection_edges_node\\": unwrap_fragment_participantsConnection_edges_node,
  };
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`TestPagination_query]) => fragmentRef =
  \\"%identity\\";

module Utils = {
  open Types;
  let getConnectionNodes:
    option(fragment_participantsConnection) =>
    array(fragment_participantsConnection_edges_node) =
    connection =>
      switch (connection) {
      | None => [||]
      | Some(connection) =>
        switch (connection.edges) {
        | None => [||]
        | Some(edges) =>
          edges->Belt.Array.keepMap(edge =>
            switch (edge) {
            | None => None
            | Some(edge) =>
              switch (edge.node) {
              | None => None
              | Some(node) => Some(node)
              }
            }
          )
        }
      };
};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Query connections generates helpers for nested connection 1`] = `
"// TestPagination_query.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type fragment_me = {
    friendsConnection: option(fragment_me_friendsConnection),
  }
  and fragment_me_friendsConnection = {
    edges: option(array(option(fragment_me_friendsConnection_edges))),
  }
  and fragment_me_friendsConnection_edges = {
    node: option(fragment_me_friendsConnection_edges_node),
  }
  and fragment_me_friendsConnection_edges_node = {
    id: string,
    firstName: string,
  };

  type fragment = {me: fragment_me};
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"me_friendsConnection\\":{\\"n\\":\\"\\"},\\"me_friendsConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"me_friendsConnection_edges_node\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`TestPagination_query]) => fragmentRef =
  \\"%identity\\";

module Utils = {
  open Types;
  let getConnectionNodes:
    option(fragment_me_friendsConnection) =>
    array(fragment_me_friendsConnection_edges_node) =
    connection =>
      switch (connection) {
      | None => [||]
      | Some(connection) =>
        switch (connection.edges) {
        | None => [||]
        | Some(edges) =>
          edges->Belt.Array.keepMap(edge =>
            switch (edge) {
            | None => None
            | Some(edge) =>
              switch (edge.node) {
              | None => None
              | Some(node) => Some(node)
              }
            }
          )
        }
      };
};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Query connections generates helpers for root level connection 1`] = `
"// TestPagination_query.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type fragment_usersConnection = {
    edges: option(array(option(fragment_usersConnection_edges))),
  }
  and fragment_usersConnection_edges = {
    node: option(fragment_usersConnection_edges_node),
  }
  and fragment_usersConnection_edges_node = {
    id: string,
    firstName: string,
  };

  type fragment = {usersConnection: option(fragment_usersConnection)};
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"usersConnection\\":{\\"n\\":\\"\\"},\\"usersConnection_edges_node\\":{\\"n\\":\\"\\"},\\"usersConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"}}} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`TestPagination_query]) => fragmentRef =
  \\"%identity\\";

module Utils = {
  open Types;
  let getConnectionNodes:
    option(fragment_usersConnection) =>
    array(fragment_usersConnection_edges_node) =
    connection =>
      switch (connection) {
      | None => [||]
      | Some(connection) =>
        switch (connection.edges) {
        | None => [||]
        | Some(edges) =>
          edges->Belt.Array.keepMap(edge =>
            switch (edge) {
            | None => None
            | Some(edge) =>
              switch (edge.node) {
              | None => None
              | Some(node) => Some(node)
              }
            }
          )
        }
      };
};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Query prints simple responses and variables 1`] = `
"// appQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_user = {
    id: string,
    firstName: string,
  };

  type response = {user: option(response_user)};
  type rawResponse = response;
  type refetchVariables = {userId: option(string)};
  let makeRefetchVariables = (~userId=?, ()): refetchVariables => {
    userId: userId,
  };
  type variables = {userId: string};
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"user\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"user\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {
  open Types;
  let makeVariables = (~userId): variables => {userId: userId};
};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests Subscription prints the correct basic structure for subscriptions 1`] = `
"// SomeSubscription.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_userChanged = {user: option(response_userChanged_user)}
  and response_userChanged_user = {
    id: string,
    firstName: string,
  }
  and userChangedInput = {
    clientMutationId: option(string),
    userId: string,
  };

  type response = {userChanged: response_userChanged};
  type rawResponse = response;
  type variables = {input: userChangedInput};
};

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"userChanged_user\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"input\\":{\\"r\\":\\"UserChangedInput\\"}},\\"UserChangedInput\\":{\\"clientMutationId\\":{\\"n\\":\\"\\"}}} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

module Utils = {
  open Types;
  let make_userChangedInput =
      (~clientMutationId=?, ~userId, ()): userChangedInput => {
    clientMutationId,
    userId,
  };

  let makeVariables = (~input): variables => {input: input};
};

type relayOperationNode;

type operationType = ReasonRelay.subscriptionNode(relayOperationNode);

"
`;

exports[`Language plugin tests Unions generates code to unwrap fragments on unions 1`] = `
"// app_user.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];

  type fragment = {
    id: string,
    firstName: string,
  };
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`app_user]) => fragmentRef =
  \\"%identity\\";

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);



// app_observer.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];

  type fragment = {
    id: string,
    name: string,
  };
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`app_observer]) => fragmentRef =
  \\"%identity\\";

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);



// appQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_participantById_User = {
    id: string,
    fragmentRefs: ReasonRelay.fragmentRefs([ | \`app_user]),
  };
  type response_participantById_Observer = {
    id: string,
    fragmentRefs: ReasonRelay.fragmentRefs([ | \`app_observer]),
  };
  type response_participantById = [
    | \`User(response_participantById_User)
    | \`Observer(response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ];

  type response = {
    participantById:
      option(
        [
          | \`User(response_participantById_User)
          | \`Observer(response_participantById_Observer)
          | \`UnselectedUnionMember(string)
        ],
      ),
  };
  type rawResponse = response;
  type variables = unit;
};

let unwrap_response_participantById:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.response_participantById_User)
    | \`Observer(Types.response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | \\"Observer\\" => \`Observer(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_response_participantById:
  [
    | \`User(Types.response_participantById_User)
    | \`Observer(Types.response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`Observer(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById_observer\\":{\\"f\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_user\\":{\\"f\\":\\"\\"}}} |json}
  ];
  let wrapResponseConverterMap = {
    \\"response_participantById\\": wrap_response_participantById,
  };
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById_observer\\":{\\"f\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_user\\":{\\"f\\":\\"\\"}}} |json}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": unwrap_response_participantById,
  };
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests Unions generates code to unwrap unions 1`] = `
"// appQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_participantById_User_location = {
    lat: float,
    lng: float,
  };
  type response_participantById_User = {
    location: response_participantById_User_location,
    lastName: string,
    firstName: string,
    id: string,
  };
  type response_participantById_Observer = {
    name: string,
    id: string,
  };
  type response_participantById = [
    | \`User(response_participantById_User)
    | \`Observer(response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ];

  type response = {
    participantById:
      option(
        [
          | \`User(response_participantById_User)
          | \`Observer(response_participantById_Observer)
          | \`UnselectedUnionMember(string)
        ],
      ),
  };
  type rawResponse = response;
  type variables = unit;
};

let unwrap_response_participantById:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.response_participantById_User)
    | \`Observer(Types.response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | \\"Observer\\" => \`Observer(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_response_participantById:
  [
    | \`User(Types.response_participantById_User)
    | \`Observer(Types.response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`Observer(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}} |json}
  ];
  let wrapResponseConverterMap = {
    \\"response_participantById\\": wrap_response_participantById,
  };
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}} |json}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": unwrap_response_participantById,
  };
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests Unions handles fragments on unions 1`] = `
"// Participant_participant.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type fragment_User_location = {
    id: string,
    lat: float,
    lng: float,
  };
  type fragment_User = {
    location: fragment_User_location,
    lastName: string,
    firstName: string,
    id: string,
  };
  type fragment_Observer = {
    name: string,
    id: string,
  };

  type fragment = [
    | \`User(fragment_User)
    | \`Observer(fragment_Observer)
    | \`UnselectedUnionMember(string)
  ];
};

let unwrap_fragment:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.fragment_User)
    | \`Observer(Types.fragment_Observer)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | \\"Observer\\" => \`Observer(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_fragment:
  [
    | \`User(Types.fragment_User)
    | \`Observer(Types.fragment_Observer)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`Observer(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"\\":{\\"u\\":\\"fragment\\"}}} |json}
  ];
  let fragmentConverterMap = {\\"fragment\\": unwrap_fragment};
  let convertFragment = v =>
    v->ReasonRelay.convertObj(
      fragmentConverter,
      fragmentConverterMap,
      Js.undefined,
    );
};

type t;
type fragmentRef;
external getFragmentRef:
  ReasonRelay.fragmentRefs([> | \`Participant_participant]) => fragmentRef =
  \\"%identity\\";

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.fragmentNode(relayOperationNode);

"
`;

exports[`Language plugin tests Unions handles nested unions 1`] = `
"// appQuery.graphql
/* @generated */

module Types = {
  type enum_ObserverStatus = pri [> | \`Active | \`Inactive];

  [@ocaml.warning \\"-30\\"];
  type response_participantById_Observer_manager_User = {
    lastName: string,
    firstName: string,
    id: string,
  };
  type response_participantById_Observer_manager_Observer = {
    status: enum_ObserverStatus,
    isOnline: option(bool),
    id: string,
  };
  type response_participantById_Observer_manager = [
    | \`User(response_participantById_Observer_manager_User)
    | \`Observer(response_participantById_Observer_manager_Observer)
    | \`UnselectedUnionMember(string)
  ];
  type response_participantById_User = {
    lastName: string,
    firstName: string,
    id: string,
  };
  type response_participantById_Observer = {
    manager:
      option(
        [
          | \`User(response_participantById_Observer_manager_User)
          | \`Observer(response_participantById_Observer_manager_Observer)
          | \`UnselectedUnionMember(string)
        ],
      ),
    name: string,
    id: string,
  };
  type response_participantById = [
    | \`User(response_participantById_User)
    | \`Observer(response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ];

  type response = {
    participantById:
      option(
        [
          | \`User(response_participantById_User)
          | \`Observer(response_participantById_Observer)
          | \`UnselectedUnionMember(string)
        ],
      ),
  };
  type rawResponse = response;
  type variables = unit;
};

let unwrap_response_participantById_Observer_manager:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.response_participantById_Observer_manager_User)
    | \`Observer(Types.response_participantById_Observer_manager_Observer)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | \\"Observer\\" => \`Observer(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_response_participantById_Observer_manager:
  [
    | \`User(Types.response_participantById_Observer_manager_User)
    | \`Observer(Types.response_participantById_Observer_manager_Observer)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`Observer(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

let unwrap_response_participantById:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.response_participantById_User)
    | \`Observer(Types.response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | \\"Observer\\" => \`Observer(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_response_participantById:
  [
    | \`User(Types.response_participantById_User)
    | \`Observer(Types.response_participantById_Observer)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`Observer(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById_observer_manager_observer_isOnline\\":{\\"n\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_observer_manager\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById_Observer_manager\\"}}} |json}
  ];
  let wrapResponseConverterMap = {
    \\"response_participantById\\": wrap_response_participantById,
    \\"response_participantById_Observer_manager\\": wrap_response_participantById_Observer_manager,
  };
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById_observer_manager_observer_isOnline\\":{\\"n\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_observer_manager\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById_Observer_manager\\"}}} |json}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": unwrap_response_participantById,
    \\"response_participantById_Observer_manager\\": unwrap_response_participantById_Observer_manager,
  };
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw = wrapResponseRaw;
  let convertWrapRawResponse = convertWrapResponse;

  type rawResponseRaw = responseRaw;
  let convertRawResponse = convertResponse;

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {
  external observerStatus_toString: Types.enum_ObserverStatus => string =
    \\"%identity\\";
};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests raw_response_type handles the Node interface in @raw_response_type 1`] = `
"// SomeQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_node = {
    __typename: [ | \`User],
    id: string,
    firstName: string,
  }
  and rawResponse_node = {
    __typename: [ | \`User],
    id: string,
    firstName: string,
  };

  type response = {node: option(response_node)};
  type rawResponse = {node: option(rawResponse_node)};
  type variables = unit;
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw;
  let wrapRawResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}} |json}
  ];
  let wrapRawResponseConverterMap = ();
  let convertWrapRawResponse = v =>
    v->ReasonRelay.convertObj(
      wrapRawResponseConverter,
      wrapRawResponseConverterMap,
      Js.null,
    );

  type rawResponseRaw;
  let rawResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}} |json}
  ];
  let rawResponseConverterMap = ();
  let convertRawResponse = v =>
    v->ReasonRelay.convertObj(
      rawResponseConverter,
      rawResponseConverterMap,
      Js.undefined,
    );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests raw_response_type handles unions in @raw_response_type 1`] = `
"// SomeQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type rawResponse_participantById_User = {
    firstName: string,
    id: string,
  };
  type rawResponse_participantById = [
    | \`User(rawResponse_participantById_User)
    | \`UnselectedUnionMember(string)
  ];
  type response_participantById_User = {
    firstName: string,
    id: string,
  };
  type response_participantById = [
    | \`User(response_participantById_User)
    | \`UnselectedUnionMember(string)
  ];

  type response = {
    participantById:
      option(
        [
          | \`User(response_participantById_User)
          | \`UnselectedUnionMember(string)
        ],
      ),
  };
  type rawResponse = {
    participantById:
      option(
        [
          | \`User(rawResponse_participantById_User)
          | \`UnselectedUnionMember(string)
        ],
      ),
  };
  type variables = unit;
};

let unwrap_rawResponse_participantById:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.rawResponse_participantById_User)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_rawResponse_participantById:
  [
    | \`User(Types.rawResponse_participantById_User)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

let unwrap_response_participantById:
  {. \\"__typename\\": string} =>
  [
    | \`User(Types.response_participantById_User)
    | \`UnselectedUnionMember(string)
  ] =
  u =>
    switch (u##__typename) {
    | \\"User\\" => \`User(u->Obj.magic)
    | v => \`UnselectedUnionMember(v)
    };

let wrap_response_participantById:
  [
    | \`User(Types.response_participantById_User)
    | \`UnselectedUnionMember(string)
  ] =>
  {. \\"__typename\\": string} =
  fun
  | \`User(v) => v->Obj.magic
  | \`UnselectedUnionMember(v) => {\\"__typename\\": v};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}} |json}
  ];
  let wrapResponseConverterMap = {
    \\"response_participantById\\": wrap_response_participantById,
  };
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}} |json}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": unwrap_response_participantById,
  };
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw;
  let wrapRawResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"rawResponse_participantById\\"}}} |json}
  ];
  let wrapRawResponseConverterMap = {
    \\"rawResponse_participantById\\": wrap_rawResponse_participantById,
  };
  let convertWrapRawResponse = v =>
    v->ReasonRelay.convertObj(
      wrapRawResponseConverter,
      wrapRawResponseConverterMap,
      Js.null,
    );

  type rawResponseRaw;
  let rawResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"rawResponse_participantById\\"}}} |json}
  ];
  let rawResponseConverterMap = {
    \\"rawResponse_participantById\\": unwrap_rawResponse_participantById,
  };
  let convertRawResponse = v =>
    v->ReasonRelay.convertObj(
      rawResponseConverter,
      rawResponseConverterMap,
      Js.undefined,
    );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;

exports[`Language plugin tests raw_response_type outputs code for handling @raw_response_type 1`] = `
"// SomeQuery.graphql
/* @generated */

module Types = {
  [@ocaml.warning \\"-30\\"];
  type response_me = {
    firstName: string,
    lastName: string,
  }
  and rawResponse_me = {
    firstName: string,
    lastName: string,
  };

  type response = {me: response_me};
  type rawResponse = {me: rawResponse_me};
  type variables = unit;
};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v->ReasonRelay.convertObj(
      wrapResponseConverter,
      wrapResponseConverterMap,
      Js.null,
    );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v->ReasonRelay.convertObj(
      responseConverter,
      responseConverterMap,
      Js.undefined,
    );

  type wrapRawResponseRaw;
  let wrapRawResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let wrapRawResponseConverterMap = ();
  let convertWrapRawResponse = v =>
    v->ReasonRelay.convertObj(
      wrapRawResponseConverter,
      wrapRawResponseConverterMap,
      Js.null,
    );

  type rawResponseRaw;
  let rawResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let rawResponseConverterMap = ();
  let convertRawResponse = v =>
    v->ReasonRelay.convertObj(
      rawResponseConverter,
      rawResponseConverterMap,
      Js.undefined,
    );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {json| {} |json}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v->ReasonRelay.convertObj(
      variablesConverter,
      variablesConverterMap,
      Js.undefined,
    );
};

type queryRef;

module Utils = {};

type relayOperationNode;

type operationType = ReasonRelay.queryNode(relayOperationNode);

"
`;
