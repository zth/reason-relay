// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Language plugin tests Explicit __typename selection throws when selecting a union without an explicit __typename selection 1`] = `
[GraphQLError: - Unions and interfaces must have the field __typename explicitly selected. Please add __typename to the fields selected by "participantById" in your operation.
  
  Source: GraphQL request (2:13)
  1: query SomeQuery {
  2:             participantById(id: "123") {
                 ^
  3:               ... on User {
  ]
`;

exports[`Language plugin tests Field names Cannot start with uppercase letter throws when trying to use a field name starting with an uppercase 1`] = `
[GraphQLError: - Found an invalid field name: Field names may not start with an uppercase letter. Please alias the 'Observer' field to something starting with a lowercase letter.
  
  Source: GraphQL request (2:13)
  1: query SomeQuery {
  2:             Observer(id: "123") {
                 ^
  3:               id
  ]
`;

exports[`Language plugin tests Field names Reserved keywords renames reserved keywords as field names in types when encountered 1`] = `
"// SomeMutation.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec mutationWithReservedNameInput = {
2  @as(\\"or\\") or_: bool,
2  @as(\\"and\\") and_: string,
2  nested: option<mutationWithReservedNameInput>,
2}
2type response = {
2  mutationWithReservedName: bool,
2}
2type rawResponse = response
2type variables = {
2  input: mutationWithReservedNameInput,
2}
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"MutationWithReservedNameInput\\":{\\"nested\\":{\\"n\\":\\"\\",\\"r\\":\\"MutationWithReservedNameInput\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"MutationWithReservedNameInput\\"}}}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}


module Utils = {
2let make_mutationWithReservedNameInput = (
2  ~or_,
2  ~and_,
2  ~nested=?,
2  ()
2): mutationWithReservedNameInput => {
2  or_: or_,
2  and_: and_,
2  nested: nested
2}
2
2let makeVariables = (
2  ~input
2): variables => {
2  input: input
2}
2let makeOptimisticResponse = (
2  ~mutationWithReservedName
2): rawResponse => {
2  mutationWithReservedName: mutationWithReservedName
2}
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.mutationNode<relayOperationNode>

"
`;

exports[`Language plugin tests Field names Reserved keywords throws when trying to use a field name that's a reserved keyword 1`] = `
[GraphQLError: - Found an invalid field name: 'new' is a reserved keyword in ReasonML and therefore cannot be used as a field name. Please alias your field to something else.
  
  Source: GraphQL request (3:17)
  2:               user(id: "123") {
  3:                 new
                     ^
  4:               }
  ]
`;

exports[`Language plugin tests Fragment prints indications of existing fragment refs in generated types 1`] = `
"// SomeComponent_user.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment = {
2  id: string,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #SomeComponent_user]> => fragmentRef = \\"%identity\\"


module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>



// SomeOtherComponent_user.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment = {
2  fragmentRefs: ReasonRelay.fragmentRefs<[ | #SomeComponent_user]>
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"\\":{\\"f\\":\\"\\"}}}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #SomeOtherComponent_user]> => fragmentRef = \\"%identity\\"


module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Fragment prints the correct fragment ref extractor helpers and base types 1`] = `
"// SomeComponent_user.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment = {
2  id: string,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #SomeComponent_user]> => fragmentRef = \\"%identity\\"


module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Mutation generates the correct converter for complex variables 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type enum_UserRole = private [>
2  | #Admin
2  | #User
2]
2
2type rec response_setUserLocation = {
2  changedUser: option<response_setUserLocation_changedUser>,
2}
2 and response_setUserLocation_changedUser = {
2  id: string,
2  firstName: string,
2  role: enum_UserRole,
2}
2 and setUserLocationInput = {
2  clientMutationId: option<string>,
2  userId: string,
2  location: option<locationBounds>,
2}
2 and locationBounds = {
2  lat: float,
2  lng: float,
2  child: option<locationBounds>,
2}
2
2
2type response = {
2  setUserLocation: response_setUserLocation,
2}
2type rawResponse = response
2type variables = {
2  input: setUserLocationInput,
2}
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"SetUserLocationInput\\":{\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"},\\"clientMutationId\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}


module Utils = {
2external userRole_toString:
2  Types.enum_UserRole => string = \\"%identity\\"
2let make_locationBounds = (
2  ~lat,
2  ~lng,
2  ~child=?,
2  ()
2): locationBounds => {
2  lat: lat,
2  lng: lng,
2  child: child
2}
2
2let make_setUserLocationInput = (
2  ~clientMutationId=?,
2  ~userId,
2  ~location=?,
2  ()
2): setUserLocationInput => {
2  clientMutationId: clientMutationId,
2  userId: userId,
2  location: location
2}
2
2let makeVariables = (
2  ~input
2): variables => {
2  input: input
2}
2let make_response_setUserLocation_changedUser = (
2  ~id,
2  ~firstName,
2  ~role
2): response_setUserLocation_changedUser => {
2  id: id,
2  firstName: firstName,
2  role: role
2}
2let make_response_setUserLocation = (
2  ~changedUser=?,
2  ()
2): response_setUserLocation => {
2  changedUser: changedUser
2}
2let makeOptimisticResponse = (
2  ~setUserLocation
2): rawResponse => {
2  setUserLocation: setUserLocation
2}
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.mutationNode<relayOperationNode>

"
`;

exports[`Language plugin tests Mutation generates the correct type structure when fragments are included 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_setUserLocation = {
2  changedUser: option<response_setUserLocation_changedUser>,
2}
2 and response_setUserLocation_changedUser = ReasonRelay.allFieldsMasked
2 and setUserLocationInput = {
2  clientMutationId: option<string>,
2  userId: string,
2  location: option<locationBounds>,
2}
2 and locationBounds = {
2  lat: float,
2  lng: float,
2  child: option<locationBounds>,
2}
2
2
2type response = {
2  setUserLocation: response_setUserLocation,
2}
2type rawResponse = response
2type variables = {
2  input: setUserLocationInput,
2}
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"f\\":\\"\\",\\"n\\":\\"\\"}}}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"f\\":\\"\\",\\"n\\":\\"\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"SetUserLocationInput\\":{\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"},\\"clientMutationId\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}


module Utils = {
2let make_locationBounds = (
2  ~lat,
2  ~lng,
2  ~child=?,
2  ()
2): locationBounds => {
2  lat: lat,
2  lng: lng,
2  child: child
2}
2
2let make_setUserLocationInput = (
2  ~clientMutationId=?,
2  ~userId,
2  ~location=?,
2  ()
2): setUserLocationInput => {
2  clientMutationId: clientMutationId,
2  userId: userId,
2  location: location
2}
2
2let makeVariables = (
2  ~input
2): variables => {
2  input: input
2}
2let make_response_setUserLocation_changedUser = (
2) => Js.Obj.empty()
2let make_response_setUserLocation = (
2  ~changedUser=?,
2  ()
2): response_setUserLocation => {
2  changedUser: changedUser
2}
2let makeOptimisticResponse = (
2  ~setUserLocation
2): rawResponse => {
2  setUserLocation: setUserLocation
2}
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.mutationNode<relayOperationNode>



// SomeFragment_user.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type enum_UserRole = private [>
2  | #Admin
2  | #User
2]
2
2type fragment = {
2  firstName: string,
2  role: enum_UserRole,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #SomeFragment_user]> => fragmentRef = \\"%identity\\"


module Utils = {
2external userRole_toString:
2  Types.enum_UserRole => string = \\"%identity\\"
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Mutation prints the correct basic structure for mutations 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_setUserLocation = {
2  changedUser: option<response_setUserLocation_changedUser>,
2}
2 and response_setUserLocation_changedUser = {
2  id: string,
2  firstName: string,
2}
2 and setUserLocationInput = {
2  clientMutationId: option<string>,
2  userId: string,
2  location: option<locationBounds>,
2}
2 and locationBounds = {
2  lat: float,
2  lng: float,
2  child: option<locationBounds>,
2}
2
2
2type response = {
2  setUserLocation: response_setUserLocation,
2}
2type rawResponse = response
2type variables = {
2  input: setUserLocationInput,
2}
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"SetUserLocationInput\\":{\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"},\\"clientMutationId\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}


module Utils = {
2let make_locationBounds = (
2  ~lat,
2  ~lng,
2  ~child=?,
2  ()
2): locationBounds => {
2  lat: lat,
2  lng: lng,
2  child: child
2}
2
2let make_setUserLocationInput = (
2  ~clientMutationId=?,
2  ~userId,
2  ~location=?,
2  ()
2): setUserLocationInput => {
2  clientMutationId: clientMutationId,
2  userId: userId,
2  location: location
2}
2
2let makeVariables = (
2  ~input
2): variables => {
2  input: input
2}
2let make_response_setUserLocation_changedUser = (
2  ~id,
2  ~firstName
2): response_setUserLocation_changedUser => {
2  id: id,
2  firstName: firstName
2}
2let make_response_setUserLocation = (
2  ~changedUser=?,
2  ()
2): response_setUserLocation => {
2  changedUser: changedUser
2}
2let makeOptimisticResponse = (
2  ~setUserLocation
2): rawResponse => {
2  setUserLocation: setUserLocation
2}
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.mutationNode<relayOperationNode>

"
`;

exports[`Language plugin tests Node interface collapses single selections on the node interface 1`] = `
"// SomeQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_node = {
2  __typename: [ | #User],
2  firstName: string,
2}
2type response = {
2  node: option<response_node>,
2}
2type rawResponse = response
2type variables = unit
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests Query connections generates helpers for connections with unions 1`] = `
"// TestPagination_query.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment_participantsConnection_edges_node_User = {
2  firstName: string,
2  id: string,
2}
2
2type fragment_participantsConnection_edges_node_Observer = {
2  name: string,
2  id: string,
2}
2
2
2type fragment_participantsConnection_edges_node = [
2  | #User(fragment_participantsConnection_edges_node_User)
2
2  | #Observer(fragment_participantsConnection_edges_node_Observer)
2  | #UnselectedUnionMember(string)
2]
2type rec fragment_participantsConnection = {
2  edges: option<array<option<fragment_participantsConnection_edges>>>,
2}
2 and fragment_participantsConnection_edges = {
2  node: option<[
2    | #User(fragment_participantsConnection_edges_node_User)
2
2    | #Observer(fragment_participantsConnection_edges_node_Observer)
2    | #UnselectedUnionMember(string)
2  ]>,
2}
2
2
2type fragment = {
2  participantsConnection: option<fragment_participantsConnection>,
2}
}

let unwrap_fragment_participantsConnection_edges_node: {. \\"__typename\\": string } => [
  | #User(Types.fragment_participantsConnection_edges_node_User)

  | #Observer(Types.fragment_participantsConnection_edges_node_Observer)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | \\"Observer\\" => #Observer(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_fragment_participantsConnection_edges_node: [
  | #User(Types.fragment_participantsConnection_edges_node_User)

  | #Observer(Types.fragment_participantsConnection_edges_node_Observer)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #Observer(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantsConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"participantsConnection_edges_node\\":{\\"n\\":\\"\\",\\"u\\":\\"fragment_participantsConnection_edges_node\\"},\\"participantsConnection\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let fragmentConverterMap = {
2  \\"fragment_participantsConnection_edges_node\\": unwrap_fragment_participantsConnection_edges_node,
2}
2
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #TestPagination_query]> => fragmentRef = \\"%identity\\"


module Utils = {
2let getConnectionNodes:
2  option<fragment_participantsConnection> => array<fragment_participantsConnection_edges_node> =
2  connection => switch connection {
2  | None => []
2  | Some(connection) => switch connection.edges { 
2   | None => []
2   | Some(edges) => edges->Belt.Array.keepMap(edge => switch edge { 
2    | None => None 
2    | Some(edge) => edge.node
2
2   })
2  }}open Types
}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Query connections generates helpers for nested connection 1`] = `
"// TestPagination_query.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2@ocaml.doc(\\"Hint: You can extract all nodes from this connection to an array of non-nullable nodes using the \`FragmentModule.getConnectionNodes\` helper, like \`let nodes = FragmentModule.getConnectionNodes(connectionGoesHere)\`. \`FragmentModule\` is whatever you've named the module where you have defined your fragment.\\") type rec fragment_me = {
2  friendsConnection: option<fragment_me_friendsConnection>,
2}
2 and fragment_me_friendsConnection = {
2  edges: option<array<option<fragment_me_friendsConnection_edges>>>,
2}
2 and fragment_me_friendsConnection_edges = {
2  node: option<fragment_me_friendsConnection_edges_node>,
2}
2 and fragment_me_friendsConnection_edges_node = {
2  id: string,
2  firstName: string,
2}
2
2
2type fragment = {
2  me: fragment_me,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"me_friendsConnection\\":{\\"n\\":\\"\\"},\\"me_friendsConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"me_friendsConnection_edges_node\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #TestPagination_query]> => fragmentRef = \\"%identity\\"


module Utils = {
2let getConnectionNodes:
2  option<fragment_me_friendsConnection> => array<fragment_me_friendsConnection_edges_node> =
2  connection => switch connection {
2  | None => []
2  | Some(connection) => switch connection.edges { 
2   | None => []
2   | Some(edges) => edges->Belt.Array.keepMap(edge => switch edge { 
2    | None => None 
2    | Some(edge) => edge.node
2
2   })
2  }}open Types
}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Query connections generates helpers for root level connection 1`] = `
"// TestPagination_query.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec fragment_usersConnection = {
2  edges: option<array<option<fragment_usersConnection_edges>>>,
2}
2 and fragment_usersConnection_edges = {
2  node: option<fragment_usersConnection_edges_node>,
2}
2 and fragment_usersConnection_edges_node = {
2  id: string,
2  firstName: string,
2}
2
2
2type fragment = {
2  usersConnection: option<fragment_usersConnection>,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"usersConnection\\":{\\"n\\":\\"\\"},\\"usersConnection_edges_node\\":{\\"n\\":\\"\\"},\\"usersConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"}}}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #TestPagination_query]> => fragmentRef = \\"%identity\\"


module Utils = {
2let getConnectionNodes:
2  option<fragment_usersConnection> => array<fragment_usersConnection_edges_node> =
2  connection => switch connection {
2  | None => []
2  | Some(connection) => switch connection.edges { 
2   | None => []
2   | Some(edges) => edges->Belt.Array.keepMap(edge => switch edge { 
2    | None => None 
2    | Some(edge) => edge.node
2
2   })
2  }}open Types
}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Query prints simple responses and variables 1`] = `
"// appQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_user = {
2  id: string,
2  firstName: string,
2}
2type response = {
2  user: option<response_user>,
2}
2type rawResponse = response
2type refetchVariables = {
2  userId: option<string>,
2}
2let makeRefetchVariables = (
2  ~userId=?,
2  ()
2): refetchVariables => {
2  userId: userId
2}
2
2type variables = {
2  userId: string,
2}
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"user\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"user\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {
2let makeVariables = (
2  ~userId
2): variables => {
2  userId: userId
2}
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests Subscription prints the correct basic structure for subscriptions 1`] = `
"// SomeSubscription.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_userChanged = {
2  user: option<response_userChanged_user>,
2}
2 and response_userChanged_user = {
2  id: string,
2  firstName: string,
2}
2 and userChangedInput = {
2  clientMutationId: option<string>,
2  userId: string,
2}
2
2
2type response = {
2  userChanged: response_userChanged,
2}
2type rawResponse = response
2type variables = {
2  input: userChangedInput,
2}
}

module Internal = {
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"userChanged_user\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"input\\":{\\"r\\":\\"UserChangedInput\\"}},\\"UserChangedInput\\":{\\"clientMutationId\\":{\\"n\\":\\"\\"}}}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}


module Utils = {
2let make_userChangedInput = (
2  ~clientMutationId=?,
2  ~userId,
2  ()
2): userChangedInput => {
2  clientMutationId: clientMutationId,
2  userId: userId
2}
2
2let makeVariables = (
2  ~input
2): variables => {
2  input: input
2}
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.subscriptionNode<relayOperationNode>

"
`;

exports[`Language plugin tests Unions generates code to unwrap fragments on unions 1`] = `
"// app_user.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment = {
2  id: string,
2  firstName: string,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #app_user]> => fragmentRef = \\"%identity\\"


module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>



// app_observer.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment = {
2  id: string,
2  name: string,
2}
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let fragmentConverterMap = ()
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #app_observer]> => fragmentRef = \\"%identity\\"


module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>



// appQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type response_participantById_User = {
2  id: string,
2  fragmentRefs: ReasonRelay.fragmentRefs<[ | #app_user]>
2}
2
2type response_participantById_Observer = {
2  id: string,
2  fragmentRefs: ReasonRelay.fragmentRefs<[ | #app_observer]>
2}
2
2
2type response_participantById = [
2  | #User(response_participantById_User)
2
2  | #Observer(response_participantById_Observer)
2  | #UnselectedUnionMember(string)
2]
2type response = {
2  participantById: option<[
2    | #User(response_participantById_User)
2
2    | #Observer(response_participantById_Observer)
2    | #UnselectedUnionMember(string)
2  ]>,
2}
2type rawResponse = response
2type variables = unit
}

let unwrap_response_participantById: {. \\"__typename\\": string } => [
  | #User(Types.response_participantById_User)

  | #Observer(Types.response_participantById_Observer)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | \\"Observer\\" => #Observer(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_response_participantById: [
  | #User(Types.response_participantById_User)

  | #Observer(Types.response_participantById_Observer)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #Observer(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById_observer\\":{\\"f\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_user\\":{\\"f\\":\\"\\"}}}\`
2  )
2
2let wrapResponseConverterMap = {
2  \\"response_participantById\\": wrap_response_participantById,
2}
2
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById_observer\\":{\\"f\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_user\\":{\\"f\\":\\"\\"}}}\`
2  )
2
2let responseConverterMap = {
2  \\"response_participantById\\": unwrap_response_participantById,
2}
2
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests Unions generates code to unwrap unions 1`] = `
"// appQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type response_participantById_User_location = {
2  lat: float,
2  lng: float,
2}
2
2type response_participantById_User = {
2  location: response_participantById_User_location,
2  lastName: string,
2  firstName: string,
2  id: string,
2}
2
2type response_participantById_Observer = {
2  name: string,
2  id: string,
2}
2
2
2type response_participantById = [
2  | #User(response_participantById_User)
2
2  | #Observer(response_participantById_Observer)
2  | #UnselectedUnionMember(string)
2]
2type response = {
2  participantById: option<[
2    | #User(response_participantById_User)
2
2    | #Observer(response_participantById_Observer)
2    | #UnselectedUnionMember(string)
2  ]>,
2}
2type rawResponse = response
2type variables = unit
}

let unwrap_response_participantById: {. \\"__typename\\": string } => [
  | #User(Types.response_participantById_User)

  | #Observer(Types.response_participantById_Observer)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | \\"Observer\\" => #Observer(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_response_participantById: [
  | #User(Types.response_participantById_User)

  | #Observer(Types.response_participantById_Observer)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #Observer(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}}\`
2  )
2
2let wrapResponseConverterMap = {
2  \\"response_participantById\\": wrap_response_participantById,
2}
2
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}}\`
2  )
2
2let responseConverterMap = {
2  \\"response_participantById\\": unwrap_response_participantById,
2}
2
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests Unions handles fragments on unions 1`] = `
"// Participant_participant.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type fragment_User_location = {
2  id: string,
2  lat: float,
2  lng: float,
2}
2
2type fragment_User = {
2  location: fragment_User_location,
2  lastName: string,
2  firstName: string,
2  id: string,
2}
2
2type fragment_Observer = {
2  name: string,
2  id: string,
2}
2
2
2type fragment = [
2  | #User(fragment_User)
2
2  | #Observer(fragment_Observer)
2  | #UnselectedUnionMember(string)
2]
}

let unwrap_fragment: {. \\"__typename\\": string } => [
  | #User(Types.fragment_User)

  | #Observer(Types.fragment_Observer)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | \\"Observer\\" => #Observer(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_fragment: [
  | #User(Types.fragment_User)

  | #Observer(Types.fragment_Observer)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #Observer(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

module Internal = {
2type fragmentRaw
2let fragmentConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"\\":{\\"u\\":\\"fragment\\"}}}\`
2  )
2
2let fragmentConverterMap = {
2  \\"fragment\\": unwrap_fragment,
2}
2
2let convertFragment = v => v->ReasonRelay.convertObj(
2  fragmentConverter, 
2  fragmentConverterMap, 
2  Js.undefined
2)
}
type t
type fragmentRef
external getFragmentRef:
  ReasonRelay.fragmentRefs<[> | #Participant_participant]> => fragmentRef = \\"%identity\\"


module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.fragmentNode<relayOperationNode>

"
`;

exports[`Language plugin tests Unions handles nested unions 1`] = `
"// appQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type enum_ObserverStatus = private [>
2  | #Active
2  | #Inactive
2]
2
2type response_participantById_Observer_manager_User = {
2  lastName: string,
2  firstName: string,
2  id: string,
2}
2
2type response_participantById_Observer_manager_Observer = {
2  status: enum_ObserverStatus,
2  isOnline: option<bool>,
2  id: string,
2}
2
2
2type response_participantById_Observer_manager = [
2  | #User(response_participantById_Observer_manager_User)
2
2  | #Observer(response_participantById_Observer_manager_Observer)
2  | #UnselectedUnionMember(string)
2]
2type response_participantById_User = {
2  lastName: string,
2  firstName: string,
2  id: string,
2}
2
2type response_participantById_Observer = {
2  manager: option<[
2    | #User(response_participantById_Observer_manager_User)
2
2    | #Observer(response_participantById_Observer_manager_Observer)
2    | #UnselectedUnionMember(string)
2  ]>,
2  name: string,
2  id: string,
2}
2
2
2type response_participantById = [
2  | #User(response_participantById_User)
2
2  | #Observer(response_participantById_Observer)
2  | #UnselectedUnionMember(string)
2]
2type response = {
2  participantById: option<[
2    | #User(response_participantById_User)
2
2    | #Observer(response_participantById_Observer)
2    | #UnselectedUnionMember(string)
2  ]>,
2}
2type rawResponse = response
2type variables = unit
}

let unwrap_response_participantById_Observer_manager: {. \\"__typename\\": string } => [
  | #User(Types.response_participantById_Observer_manager_User)

  | #Observer(Types.response_participantById_Observer_manager_Observer)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | \\"Observer\\" => #Observer(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_response_participantById_Observer_manager: [
  | #User(Types.response_participantById_Observer_manager_User)

  | #Observer(Types.response_participantById_Observer_manager_Observer)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #Observer(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

let unwrap_response_participantById: {. \\"__typename\\": string } => [
  | #User(Types.response_participantById_User)

  | #Observer(Types.response_participantById_Observer)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | \\"Observer\\" => #Observer(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_response_participantById: [
  | #User(Types.response_participantById_User)

  | #Observer(Types.response_participantById_Observer)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #Observer(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById_observer_manager_observer_isOnline\\":{\\"n\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_observer_manager\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById_Observer_manager\\"}}}\`
2  )
2
2let wrapResponseConverterMap = {
2  \\"response_participantById\\": wrap_response_participantById,
2  \\"response_participantById_Observer_manager\\": wrap_response_participantById_Observer_manager,
2}
2
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById_observer_manager_observer_isOnline\\":{\\"n\\":\\"\\"},\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_observer_manager\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById_Observer_manager\\"}}}\`
2  )
2
2let responseConverterMap = {
2  \\"response_participantById\\": unwrap_response_participantById,
2  \\"response_participantById_Observer_manager\\": unwrap_response_participantById_Observer_manager,
2}
2
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw = wrapResponseRaw
2let convertWrapRawResponse = convertWrapResponse
2type rawResponseRaw = responseRaw
2let convertRawResponse = convertResponse
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {
2external observerStatus_toString:
2  Types.enum_ObserverStatus => string = \\"%identity\\"
2open Types
}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests raw_response_type handles the Node interface in @raw_response_type 1`] = `
"// SomeQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_node = {
2  __typename: [ | #User],
2  id: string,
2  firstName: string,
2}
2 and rawResponse_node = {
2  __typename: [ | #User],
2  id: string,
2  firstName: string,
2}
2
2
2type response = {
2  node: option<response_node>,
2}
2type rawResponse = {
2  node: option<rawResponse_node>,
2}
2type variables = unit
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw
2let wrapRawResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}}\`
2  )
2
2let wrapRawResponseConverterMap = ()
2let convertWrapRawResponse = v => v->ReasonRelay.convertObj(
2  wrapRawResponseConverter, 
2  wrapRawResponseConverterMap, 
2  Js.null
2)
2type rawResponseRaw
2let rawResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"node\\":{\\"n\\":\\"\\",\\"tnf\\":\\"User\\"}}}\`
2  )
2
2let rawResponseConverterMap = ()
2let convertRawResponse = v => v->ReasonRelay.convertObj(
2  rawResponseConverter, 
2  rawResponseConverterMap, 
2  Js.undefined
2)
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests raw_response_type handles unions in @raw_response_type 1`] = `
"// SomeQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rawResponse_participantById_User = {
2  firstName: string,
2  id: string,
2}
2
2
2type rawResponse_participantById = [
2  | #User(rawResponse_participantById_User)
2  | #UnselectedUnionMember(string)
2]
2type response_participantById_User = {
2  firstName: string,
2  id: string,
2}
2
2
2type response_participantById = [
2  | #User(response_participantById_User)
2  | #UnselectedUnionMember(string)
2]
2type response = {
2  participantById: option<[
2    | #User(response_participantById_User)
2    | #UnselectedUnionMember(string)
2  ]>,
2}
2type rawResponse = {
2  participantById: option<[
2    | #User(rawResponse_participantById_User)
2    | #UnselectedUnionMember(string)
2  ]>,
2}
2type variables = unit
}

let unwrap_rawResponse_participantById: {. \\"__typename\\": string } => [
  | #User(Types.rawResponse_participantById_User)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_rawResponse_participantById: [
  | #User(Types.rawResponse_participantById_User)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

let unwrap_response_participantById: {. \\"__typename\\": string } => [
  | #User(Types.response_participantById_User)
  | #UnselectedUnionMember(string)
] = u => switch u[\\"__typename\\"] {
 | \\"User\\" => #User(u->Obj.magic) 
 | v => #UnselectedUnionMember(v)
}

let wrap_response_participantById: [
  | #User(Types.response_participantById_User)
  | #UnselectedUnionMember(string)
] => {. \\"__typename\\": string } = v => switch v {
 | #User(v) => v->Obj.magic 
 | #UnselectedUnionMember(v) => {\\"__typename\\": v} 
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}}\`
2  )
2
2let wrapResponseConverterMap = {
2  \\"response_participantById\\": wrap_response_participantById,
2}
2
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}}\`
2  )
2
2let responseConverterMap = {
2  \\"response_participantById\\": unwrap_response_participantById,
2}
2
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw
2let wrapRawResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"rawResponse_participantById\\"}}}\`
2  )
2
2let wrapRawResponseConverterMap = {
2  \\"rawResponse_participantById\\": wrap_rawResponse_participantById,
2}
2
2let convertWrapRawResponse = v => v->ReasonRelay.convertObj(
2  wrapRawResponseConverter, 
2  wrapRawResponseConverterMap, 
2  Js.null
2)
2type rawResponseRaw
2let rawResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"rawResponse_participantById\\"}}}\`
2  )
2
2let rawResponseConverterMap = {
2  \\"rawResponse_participantById\\": unwrap_rawResponse_participantById,
2}
2
2let convertRawResponse = v => v->ReasonRelay.convertObj(
2  rawResponseConverter, 
2  rawResponseConverterMap, 
2  Js.undefined
2)
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;

exports[`Language plugin tests raw_response_type outputs code for handling @raw_response_type 1`] = `
"// SomeQuery.graphql
/* @generated */
%%raw(\\"/* @generated */\\")
module Types = {
2@@ocaml.warning(\\"-30\\")
2
2type rec response_me = {
2  firstName: string,
2  lastName: string,
2}
2 and rawResponse_me = {
2  firstName: string,
2  lastName: string,
2}
2
2
2type response = {
2  me: response_me,
2}
2type rawResponse = {
2  me: rawResponse_me,
2}
2type variables = unit
}

module Internal = {
2type wrapResponseRaw
2let wrapResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let wrapResponseConverterMap = ()
2let convertWrapResponse = v => v->ReasonRelay.convertObj(
2  wrapResponseConverter, 
2  wrapResponseConverterMap, 
2  Js.null
2)
2type responseRaw
2let responseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let responseConverterMap = ()
2let convertResponse = v => v->ReasonRelay.convertObj(
2  responseConverter, 
2  responseConverterMap, 
2  Js.undefined
2)
2type wrapRawResponseRaw
2let wrapRawResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let wrapRawResponseConverterMap = ()
2let convertWrapRawResponse = v => v->ReasonRelay.convertObj(
2  wrapRawResponseConverter, 
2  wrapRawResponseConverterMap, 
2  Js.null
2)
2type rawResponseRaw
2let rawResponseConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let rawResponseConverterMap = ()
2let convertRawResponse = v => v->ReasonRelay.convertObj(
2  rawResponseConverter, 
2  rawResponseConverterMap, 
2  Js.undefined
2)
2let variablesConverter: 
2  Js.Dict.t<Js.Dict.t<Js.Dict.t<string>>> = 
2  %raw(
2    json\`{}\`
2  )
2
2let variablesConverterMap = ()
2let convertVariables = v => v->ReasonRelay.convertObj(
2  variablesConverter, 
2  variablesConverterMap, 
2  Js.undefined
2)
}

type queryRef

module Utils = {

}
type relayOperationNode
type operationType = ReasonRelay.queryNode<relayOperationNode>

"
`;
